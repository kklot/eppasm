# extract from fitmod()
# dumping everything here to clean up later
prepare_fp_likdat <- function(obj, epp, ...) {
    if(epp)
      fp <- update(attr(obj, 'eppfp'), ...)
    else
      fp <- update(attr(obj, 'specfp'), ...)

    ## Prepare likelihood data
    eppd   <- attr(obj, "eppd")
    likdat <- prepare_likdat(eppd, fp)
    
    if (exists("ancsite.dat", likdat)) {
      fp$ancsitedata <- TRUE
      fp <- prepare_anc_model(fp, eppd)
    }
    
    if (exists("ancrtcens.dat", likdat))
      fp$ancrt       = "both"
    
    if(fp$eppmod %in% c("logrw", "rhybrid", "rlogistic")) { # THIS IS REALLY MESSY, NEED TO REFACTOR CODE
      fp$SIM_YEARS <- as.integer(max(likdat$ancsite.dat$df$yidx,
                                     likdat$hhs.dat$yidx,
                                     likdat$ancrtcens.dat$yidx,
                                     likdat$hhsincid.dat$idx))
      fp$proj.steps <- with(fp$ss, seq(proj_start+0.5, proj_start-1+fp$SIM_YEARS+0.5, 
        by = 1 / fp$ss$hiv_steps_per_year))
      fp$n_steps <- length(fp$proj.steps)
    } else {
      fp$SIM_YEARS <- fp$ss$PROJ_YEARS
      fp$n_steps <- fp$SIM_YEARS * fp$ss$hiv_steps_per_year
    }

    ## Prepare the EPP model
    tsEpidemicStart <- ifelse(epp, fp$tsEpidemicStart, fp$ss$time_epi_start+0.5)
    if (fp$eppmod == "rspline")
      fp <- prepare_rspline_model(fp, tsEpidemicStart = tsEpidemicStart)
    else if (fp$eppmod == "rtrend")
      fp <- prepare_rtrend_model(fp)
    else if (fp$eppmod == "logrw")
      fp <- prepare_logrw(fp)
    else if (fp$eppmod == "rhybrid")
      fp <- prepare_rhybrid(fp)
    else if (fp$eppmod == "rlogistic")
      fp$tsEpidemicStart <-
        fp$proj.steps[which.min(abs(fp$proj.steps - fp$ss$time_epi_start+0.5))]

    fp$logitiota <- TRUE
    # only run Kinh's code if specify
    fp$VERSION  = ifelse(exists("VERSION", where=fp), fp$VERSION, "C")
    fp$ss$MODEL = 1
    if (exists("with_mixing", where=fp) && fp$with_mixing) {
      fp$VERSION    = ifelse(fp$VERSION=='C', 'K', fp$VERSION)
      fp$ss$MODEL   = 2
      fp$ss$MIX     = TRUE
      if (!exists("mixmat", where=fp))
        fp$mixmat <- readRDS(system.file("extdata", "est_mixmat_copula.rds", package="eppasm"))[[1]]
    } else
      fp$ss$MIX     = FALSE
    if (exists("with_debut", where=fp) && fp$with_debut) {
      fp$VERSION  = ifelse(fp$VERSION=='C', 'K', fp$VERSION)
      fp$ss$MODEL = 2
      if (!exists("max_debut_age", where=fp)) max_debut_age = 30
      fp = update_fp_debut(fp, max_debut_age)
    }
    fp <- fp_fill_missing(fp)
    list(fp=fp, likdat=likdat)
}

fp_fill_missing <- function(fp) {
	warning('Default values filled, check their validity in fp_fill_missing')
  if (!exists("DT", where=fp$ss)) 
    fp$ss$DT <- 1 / fp$ss$hiv_steps_per_year
  if (!exists("incidmod", where=fp)) 
    fp$incidmod <- "eppspectrum"
  fp$incidmodInt <- match(fp$incidmod, c("eppspectrum", "transm"))-1L  # -1 for 0-based indexing
  if (!exists("popadjust", where=fp))
    fp$popadjust <- FALSE
  if (is.null(dim(fp$artmx_timerr))) # repicate for 3 treatment durations
    fp$artmx_timerr <- matrix(rep(fp$artmx_timerr, 3), nrow=3, byrow=TRUE)
  if (!exists("rw_start", where=fp)) 
    fp$rw_start <- fp$rt$rw_start
  if (!exists("est_pcr", where=fp))
    fp$est_pcr <- readRDS(system.file("extdata", "est_pcr.rds", package="eppasm"))[[1]]
  if (!exists("est_senesence", where=fp))
    fp$est_senesence <- readRDS(system.file("extdata", "est_senesence.rds", package="eppasm"))[[1]]
  if (!exists("rvec", where=fp)) 
      fp$rvec <- 1
  if (!fp$popadjust) {
      fp$targetpop <- array(0, c(1,1,1))
      fp$entrantpop <- array(0, c(1,1))
  }
  if (!exists("rel_vl", where=fp))
      fp$rel_vl <- c(1, rep(.4, 5), .8)
  if (!exists("mf_transm_rr", where=fp))
      fp$mf_transm_rr <- fp$incrr_sex
  if (!exists("balancing", where=fp))
      fp$balancing <- .5 # for C++ read, not doing anything
  if (!exists("fage", where=fp))
      fp$fage <- matrix(1, 1, 2) # for C++ read, not doing anything
  if (!exists("est_pcr", where=fp))
      fp$est_pcr <- matrix(1, 1, 2) # for C++ read, not doing anything
  if (!exists("est_condom", where=fp))
      fp$est_condom <- array(0, c(66, 2, 52)) # for C++ read, not doing anything
  if (!exists("relsexact_cd4cat", where=fp))
      fp$relsexact_cd4cat <- rep(1, 7)
   # rhybrid = 0 # rtrend = 1 # directincid =2
  fp$eppmodInt <- match(fp$eppmod, c("rtrend", "directincid"), nomatch=0) # 0: r-spline;
  fp$ancrtInt <- match(fp$ancrt, c("both"), nomatch=0) # just a placeholder
  fp
}

obj_fn = function(theta, fp, likdat) {
  o <- lprior(theta, fp) + sum(ll_all(theta, fp, likdat))
  if (is.na(o) || !is.finite(o)) return (-1e6)
  o
}

#' extract from fitmod()
#' 
#' fit model with optim()
#' 
#' @param epp ...
#' @param fp fix parameters
#' @param likdat data likelihood
#' @param control_optim a list specify as optim arguments, e.g. list(fn=,control=list())
#' @param B0 Number of parameter samples to find MAP as optim's starting value
#' @param B.re Number of resamples
#' @param doParallel use mclapply when finding initial value
epp_optim <- function(epp=FALSE, fp, likdat, control_optim, B0, B.re, doParallel) {
  bounds <- apply(eppasm:::sample.prior(3000, fp), 2, range)
  .control.optim <- list(par=NULL, fn=obj_fn, method="L-BFGS-B", hessian=TRUE,
                         lower=bounds[1, ], upper = bounds[2, ],
                         control=list(fnscale=-1, trace=4, maxit=1e3))
  if (!is.null(names(control_optim)))
    .control.optim <- modifyList(.control.optim, control_optim)
  if (is.null(.control.optim$par)) { # Find starting values that MAP
    X0     = eppasm:::sample.prior(B0, fp)
    message('Searching for starting values...\r'); flush.console()
    lpost0 = eppasm:::likelihood(X0, fp, likdat, log=TRUE, doParallel) + 
             eppasm:::prior(X0, fp, log=TRUE)
    .control.optim$par = X0[which.max(lpost0)[1], ]
  }
  .control.optim$control$ndeps <- rep(1e-4, length(.control.optim$par))
  .control.optim <- modifyList(.control.optim, list(fp = fp, likdat = likdat))
  message('Starts optim...\r'); flush.console()
  opt = do.call("optim", .control.optim)
  opt$fp     = fp
  opt$likdat = likdat
  opt$param  = fnCreateParam(opt$par, opt$fp)
  opt$mod    = simmod(update(fp, list=opt$param))
  opt$ctrl   = .control.optim
  optclass   = ifelse(epp, "eppopt", "specopt")
  if (.control.optim$hessian) {
    message('Done optim, sampling...\r'); flush.console()
    opt$resample = mvtnorm::rmvnorm(B.re, opt$par, solve(-opt$hessian))
    optclass     = c(optclass, ifelse(epp, "eppfit", "specfit"))
  }
  class(opt) = optclass
  opt
}

#' Update previous fit with optim() results
#' 
#' Using best parameters as starting values 
#' @param fitOp Object return from fitmod with algorithm = 'optim'
update.specopt <- function(fitOp,...) 
{
  o = epp_optim(TRUE, fitOp$fp, fitOp$likdat, 
    control_optim = modifyList(fitOp$ctrl, list(par=fitOp$par,...)),
    B0=1e2, B.re=1e3, doParallel=F)
  return(o)
}

obj_fn_neg = function(theta, fp, likdat) 
  -(lprior(theta, fp) + sum(ll_all(theta, fp, likdat)))

#' Use in fitmod()
#' 
#' fit model with DEoptim()
#' 
#' @param epp ...
#' @param fp fix parameters
#' @param likdat data likelihood
#' @param control_DE a list specify as optim arguments, e.g. list(initpop=...)
#' @param doParallel use mclapply when finding initial value
epp_DE <- function(epp, fp, likdat, control_DE, doParallel) {
  .control.DE <- list(parallelType=doParallel, trace=1, packages=c('eppasm'))
  if (!is.null(names(control_DE))) 
    .control.DE <- modifyList(.control.DE, control_DE)
  bounds <- prior_to_DE_bounds(fp)
  o <- list()
  fit <- DEoptim::DEoptim(obj_fn_neg, bounds[,1], bounds[,2],
    fp = fp, likdat = likdat, control= .control.DE)
  o$par    = fit$optim$bestmem
  o$fit    = fit
  o$fp     = fp
  o$likdat = likdat
  o$ctrl   = .control.DE
  o$param  = fnCreateParam(o$par, fp)
  o$mod    = simmod(update(fp, list=o$param))
  class(o) = "eppDE"
  return(o)
}

#' Update previous fit with DEoptim() results
#' 
#' Using best parameters as starting values 
#' @param fitDE Object return from fitmod with algorithm = 'DE'
update.eppDE <- function(fitDE,...) {
  o = epp_DE(TRUE, fitDE$fp, fitDE$likdat, 
    modifyList(fitDE$ctrl, list(
      initpop = fitDE$member$pop,...
    )), 
    fitDE$ctrl$parallelType)
  return(o)
}
